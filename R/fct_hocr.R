#' read_hocr
#'
#' @description Reader for HOCR binary file saved by datalogger.
#' Leverage \href{https://kaitai.io/}{kaitaistruct} with python, the python custom class is lost between
#' session so the object return a null pointer. This make it impossible (?) to save
#' to file so a quick fix was to extract the values and put them in an r list.
#' Check for packet integrity by detecting valid instruments name, this may leave
#' some corrupted packets.
#'
#' @return Return a r list containing all HOCR packet value as character or numeric
#'
#' @noRd
read_hocr <- function(BinFile) {

  # now source python onload
  reticulate::source_python(system.file("py", "hocr.py", package = "sear", mustWork = T))

  RawHOCR <- purrr::map(BinFile, Hocr$from_file)

  RawHOCR <- unlist(purrr::map(RawHOCR, ~ .x$packets))

  # Unefficent way of removing custom class python object dependencies resulting in null pointer
  # How to avoid: Error in py_ref_to_r(x) : Embedded NUL in string ? (packet 27281 of AlgaeValidation (2022/07/05))

  RawHOCR <- purrr::imap(RawHOCR, ~ tryCatch(
    list(
      "channel" = .$channel,
      "checksum" = .$checksum,
      "darkaverage" = .$darkaverage,
      "darksample" = .$darksample,
      "frame" = .$frame,
      "gpstime" = .$gpstime,
      "instrument" = as.character(.$instrument, errors = "ignore"),
      "inttime" = .$inttime,
      "loggerport" = .$loggerport,
      "mysterydate" = .$mysterydate,
      "sampledelay" = .$sampledelay,
      "sn" = as.character(.$sn, errors = "ignore"),
      "spectemp" = as.character(.$spectemp, errors = "ignore"),
      "timer" = as.character(.$timer, errors = "ignore")
    ),
    error = function(...) NA
  ))

  NaPackets <- 0
  if (any(is.na(RawHOCR))) {
    RawHOCR <- RawHOCR[-which(is.na(RawHOCR))]
    NaPackets <- which(is.na(RawHOCR))
  }

  # check for invalid packet
  ValidInd <- purrr::map_lgl(RawHOCR, ~ str_detect(as.character(.x$instrument, errors = "ignore"), "SAT(HPL|HSE|HED|PLD)"))

  if (any(!ValidInd)) {
    message("Invalid HOCR packets detected and removed: ", length(which(!ValidInd)) + NaPackets)

    RawHOCR[ValidInd]
  } else {
    RawHOCR
  }
}

#' filter_hocr
#'
#' @description Time filter of the \code{RawHOCR} list (from  \code{\link{read_hocr}}) based on time interval.
#' HOCRTimeIndex is precomputed as it takes time.
#'
#' @return Return a subset of \code{RawHOCR}
#'
#' @noRd
filter_hocr <- function(RawHOCR, HOCRTimeIndex, TimeInt) {
  # Ideally the packet DateTime would be construct from the packet only ...
  # As I don't know the Date here quick and dirty fix with MainLogDate

  ind <- purrr::map_lgl(.x = HOCRTimeIndex, ~ .x %within% TimeInt)

  RawHOCR[ind]
}

#' tidy_hocr
#'
#' @description tidyer for HOCR packets.
#'
#' @param Packets list of HOCR packets generated by \code{\link{read_hocr}}
#' @param MainLogDate The binary date format added by the MTE datalogger is unknown.
#' Quick Fix
#'
#' @return Return a long format tidy tibble of the HOCR packets
#'
#' @noRd
tidy_hocr <- function(Packets, MainLogDate) {
  tibble::tibble(
    # Applanix time added by the DataLogger in millisecond
    # Unkown Date format in the binary file, so take the one in the txt file
    GPSTime = as.POSIXct(paste0(MainLogDate, hms::as_hms(Packets$gpstime / 1000)), format = "%Y-%m-%d %H:%M:%OS", tz = "UTC"),

    # HOCR Packets
    # Fix missing byte bug by ignoring decoding error
    Instrument = as.character(Packets$instrument, errors = "ignore"),
    SN = as.character(Packets$sn, errors = "ignore"),
    IntTime = Packets$inttime,
    SampleDelay = Packets$sampledelay,
    DarkSample = Packets$darksample,
    DarkAverage = Packets$darkaverage,
    SpecTemp = as.character(Packets$spectemp, errors = "ignore"),
    Frame = Packets$frame,
    Timer = as.character(Packets$timer, errors = "ignore"),
    CheckSum = Packets$checksum,
    Channels = Packets$channel
  )
}

#' cal_inttime
#'
#' @description Calibrate HOCR integration time
#'
#' @noRd
cal_inttime <- function(RawData, INTTIME) {
  a0 <- INTTIME$a0
  a1 <- INTTIME$a1

  purrr::modify_in(RawData, .where = "IntTime", ~ (a0 * .x^0) + (a1 * .x^1))
}

#' cal_optic3
#'
#' @description Calibrate HOCR optical channels
#'
#' @noRd
cal_optic3 <- function(.x, Instrument) {
  if (str_detect(Instrument, "HSE|HED")) { # In air

    dplyr::mutate(.data = .x, Channels = 1.0 * a1 * (Channels - a0) * (cint / IntTime))
  } else if (str_detect(Instrument, "HPL|PLD")) { # In water

    dplyr::mutate(.data = .x, Channels = im * a1 * (Channels - a0) * (cint / IntTime))
  } else {
    warning(paste0("Instrument name not valid: ", Instrument))
  }
}

#' approx_tbl
#'
#' @description approximate measurements on common time coordinates
#'
#' @noRd
approx_tbl <- function(., TimeSeq) {
  tbl <- tibble(DateTime = TimeSeq)

  for (i in seq_along(colnames(.))[-1]) {
    coord <- approx(x = .[[1]], y = .[[i]], xout = TimeSeq, method = "linear")

    tbl <- bind_cols(tbl, x = coord[[2]])
    colnames(tbl)[i] <- colnames(.)[i]
  }

  tbl %>% mutate(
    ID = seq_along(TimeSeq),
    QC = "1",
    .before = DateTime
  )
}

#' cal_dark
#'
#' @description Calibrate HOCR dark packets to L1b, is mostly a copy and paste
#' of \code{\link{cal_hocr}}), should improve that ...
#'
#' @return Return a wide data frame for HOCR dark offset
#'
#' @noRd
cal_dark <- function(RawHOCR, CalHOCR, MainLogDate) {
  RawData <- purrr::map_df(RawHOCR, ~ tidy_hocr(., MainLogDate))

  # Bind HOCR with Calibration by Instrument (shutter mode) -----------------

  # There will be a problem here if some HCOR packet have corrupted Instrument and SN.
  # Have to filter and remove those corrupted pakect before, in the tidy_hocr function ?

  GlobCal <- RawData %>%
    group_by(Instrument, SN) %>%
    nest(RawData = !matches("Instrument|SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$OPTIC3, by = c("Instrument", "SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$THERM1, by = c("Instrument", "SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$INTTIME, by = c("Instrument", "SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$SAMPLE, by = c("Instrument", "SN"))

  # Add OPTIC3 to raw data --------------------------------------------------

  # taken from: https://gist.github.com/mdlincoln/528a53939538b07ade86
  row_rep <- function(df, n) {
    df[rep(1:nrow(df), times = n), ]
  }

  GlobCal <- GlobCal %>% mutate(RawData = purrr::map2(RawData, OPTIC3, ~ bind_cols(.x, row_rep(.y, nrow(.x) / nrow(.y)))))

  # Calibrate time ----------------------------------------------------------

  GlobCal <- GlobCal %>% mutate(CalData = purrr::map2(.x = RawData, .y = INTTIME, .f = ~ cal_inttime(.x, .y)))

  # Calibrate optical channels ----------------------------------------------

  GlobCal <- GlobCal %>% mutate(CalData = purrr::map2(.x = CalData, .y = Instrument, ~ cal_optic3(.x, .y)))

  # Interpolate time coordinate ---------------------------------------------

  HOCRLong <- GlobCal %>% # OPTIC3
    mutate(CalData = purrr::map(
      CalData,
      ~ select(.x, !all_of(c("Units", "FieldLength", "DataType", "CalLines", "FitType", "a0", "a1", "im", "cint")))
    )) %>% # Packet metadata
    mutate(CalData = purrr::map(
      CalData,
      ~ select(.x, !all_of(c("SampleDelay", "DarkSample", "DarkAverage", "SpecTemp", "Frame", "Timer", "CheckSum")))
    )) %>%
    select(Instrument, SN, CalData)

  # Convert to wide format

  HOCRWide <- HOCRLong %>%
    mutate(CalData = purrr::map(
      CalData,
      ~ pivot_wider(
        .,
        names_from = all_of(c("Type", "Wavelength")),
        names_sep = "_",
        values_from = Channels
      )
    )) %>%
    mutate(CalData = purrr::map(CalData, ~ select(., where(function(x) all(!is.na(x))))))

  # Compute the Time Sequence

  ShortNobs <- HOCRWide %>%
    mutate(Nobs = purrr::map_dbl(CalData, ~ length(rownames(.))))

  ShortNobs <- ShortNobs %>%
    filter(Nobs == min(ShortNobs$Nobs)) %>%
    unnest(cols = c(CalData))

  MinTime <- min(ShortNobs$GPSTime)
  # format(MinTime, "%Y-%m-%d %H:%M:%OS3")

  MaxTime <- max(ShortNobs$GPSTime)
  # format(MaxTime, "%Y-%m-%d %H:%M:%OS3")

  TimeSeq <- seq.POSIXt(MinTime, MaxTime, by = 60)
  # format(TimeSeq, "%Y-%m-%d %H:%M:%OS3")

  # Interpolate to commom time coordinates

  HOCRWide <- HOCRWide %>%
    mutate(CalData = purrr::map(CalData, ~ select(., !IntTime)))

  HOCRWide <- HOCRWide %>%
    mutate(AproxData = purrr::map(CalData, ~ approx_tbl(., TimeSeq))) %>%
    select(!CalData)
}

#' cal_hocr
#'
#' @description Calibrate HOCR packets to L1b
#'
#' @param FiltRawHOCR subset from \code{\link{filter_hocr}})
#' @param CalData calibration data from \code{\link{tidy_cal_hocr}}
#' @param CalData dark data from \code{\link{cal_dark}}
#' @param MainLogDate The binary date format added by the MTE datalogger is unknown.
#' Quick Fix
#'
#' @return Return L1b HOCR data in a tidy long format
#'
#' @noRd
cal_hocr <- function(RawHOCR, CalHOCR, HOCRDark, MainLogDate, UpdateProgress) {

  # If we were passed a progress update function, call it
  if (is.function(UpdateProgress)) {
    text <- "HOCR: "
    UpdateProgress(message = text)
  }

  RawData <- purrr::map_df(RawHOCR, ~ tidy_hocr(., MainLogDate))

  # Bind HOCR with Calibration by Instrument (shutter mode) -----------------

  GlobCal <- RawData %>%
    group_by(Instrument, SN) %>%
    nest(RawData = !matches("Instrument|SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$OPTIC3, by = c("Instrument", "SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$THERM1, by = c("Instrument", "SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$INTTIME, by = c("Instrument", "SN"))

  GlobCal <- left_join(GlobCal, CalHOCR$SAMPLE, by = c("Instrument", "SN"))

  # If we were passed a progress update function, call it
  if (is.function(UpdateProgress)) {
    text <- "add OPTIC3"
    UpdateProgress(detail = text)
  }

  # Add OPTIC3 to raw data --------------------------------------------------

  # taken from: https://gist.github.com/mdlincoln/528a53939538b07ade86
  row_rep <- function(df, n) {
    df[rep(1:nrow(df), times = n), ]
  }


  GlobCal <- GlobCal %>% mutate(RawData = purrr::map2(RawData, OPTIC3, ~ bind_cols(.x, row_rep(.y, nrow(.x) / nrow(.y)))))

  # Calibrate time ----------------------------------------------------------

  if (is.function(UpdateProgress)) {
    detail <- "calibrate time"
    UpdateProgress(detail = detail)
  }

  GlobCal <- GlobCal %>% mutate(CalData = purrr::map2(.x = RawData, .y = INTTIME, .f = ~ cal_inttime(.x, .y)))

  # Calibrate optical channels ----------------------------------------------

  if (is.function(UpdateProgress)) {
    detail <- "calibrate optical channels"
    UpdateProgress(detail = detail)
  }

  GlobCal <- GlobCal %>% mutate(CalData = purrr::map2(.x = CalData, .y = Instrument, ~ cal_optic3(.x, .y)))

  # Interpolate time coordinate ---------------------------------------------

  if (is.function(UpdateProgress)) {
    detail <- "time interpolation"
    UpdateProgress(detail = detail)
  }

  HOCRLong <- GlobCal %>% # OPTIC3
    mutate(CalData = purrr::map(
      CalData,
      ~ select(.x, !all_of(c("Units", "FieldLength", "DataType", "CalLines", "FitType", "a0", "a1", "im", "cint")))
    )) %>% # Packet metadata
    mutate(CalData = purrr::map(
      CalData,
      ~ select(.x, !all_of(c("SampleDelay", "DarkSample", "DarkAverage", "SpecTemp", "Frame", "Timer", "CheckSum")))
    )) %>%
    select(Instrument, SN, CalData) %>%
    filter(str_detect(Instrument, "HSE|HPL"))

  # If not 3 instrument HSE|HPL record raise an error

  if (nrow(HOCRLong) != 3) {
    MissSn <- unique(GlobCal$SN)[which(!unique(GlobCal$SN) %in% HOCRLong$SN)]
    stop(glue::glue("No light record for instrument: ", MissSn))
  }

  # Convert to wide format

  HOCRWide <- HOCRLong %>%
    mutate(CalData = purrr::map(
      CalData,
      ~ pivot_wider(
        .,
        names_from = all_of(c("Type", "Wavelength")),
        names_sep = "_",
        values_from = Channels
      )
    )) %>%
    mutate(CalData = purrr::map(CalData, ~ select(., where(function(x) all(!is.na(x))))))

  # Compute the Time Sequence

  ShortNobs <- HOCRWide %>%
    mutate(Nobs = purrr::map_dbl(CalData, ~ length(rownames(.))))

  ShortNobs <- ShortNobs %>%
    filter(Nobs == min(ShortNobs$Nobs)) %>%
    unnest(cols = c(CalData))

  MinTime <- min(ShortNobs$GPSTime)
  # format(MinTime, "%Y-%m-%d %H:%M:%OS3")

  MaxTime <- max(ShortNobs$GPSTime)
  # format(MaxTime, "%Y-%m-%d %H:%M:%OS3")

  TimeSeq <- seq.POSIXt(MinTime, MaxTime, by = min(ShortNobs$IntTime))
  # format(TimeSeq, "%Y-%m-%d %H:%M:%OS3")

  # Interpolate to commom time coordinates

  HOCRWide <- HOCRWide %>%
    mutate(CalData = purrr::map(CalData, ~ select(., !IntTime)))

  # Debug for NA values in interpolation

  if (any(purrr::map_lgl(HOCRWide$CalData, ~ !nrow(.) > 1))) {
    MissSn <- HOCRWide$SN[purrr::map_lgl(HOCRWide$CalData, ~ !nrow(.) > 1)]
    stop(glue::glue("Cannot interpolate with one light record for instrument: ", paste0(MissSn, collapse = ", ")))
  }

  # Need to test if two non-NA values are available to interpolate
  # This is handled by wrapping cal_hocr in spsComps::shinyCatch

  HOCRWide <- HOCRWide %>%
    mutate(AproxData = purrr::map(CalData, ~ approx_tbl(., TimeSeq)))

  if (is.function(UpdateProgress)) {
    detail <- "dark correction"
    UpdateProgress(detail = detail)
  }

  # Apply dark correction

  HOCRWide <- left_join(HOCRWide, HOCRDark, by = c("SN"))

  cor_dark <- function(x, y) {

    ID <- x[, 1]
    DateTime <- x[, 2]

    Data <- x[, -1:-2] - row_rep(y[, -1:-2], nrow(x[, -1:-2]))

    bind_cols(ID, DateTime, Data)
  }

  HOCRWide <- HOCRWide %>%
    mutate(AproxData = purrr::map2(AproxData, DarkAproxData, cor_dark))

  # Transform back to long format

  if (is.function(UpdateProgress)) {
    detail <- "long time no sea"
    UpdateProgress(detail = detail)
  }

  HOCRLong <- HOCRWide %>%
    mutate(AproxData = purrr::map(
      AproxData,
      ~ pivot_longer(
        .,
        cols = matches("[[:alpha:]]{2}_[[:digit:]]{3}(.[[:digit:]]{1,2})?"),
        values_to = "Channels",
        names_to = c("Type", "Wavelength"),
        names_sep = "_",
        # names_prefix = "[[:alpha:]]{2}_",
        names_transform = list(Wavelength = as.numeric)
      ) %>%
        group_by(ID)
    ))

  # CalData is not needed further
  HOCRLong %>%
    select(!CalData & !DarkAproxData)
}

#' L2_hocr
#'
#' @description Compute L2 AOPs parameter from HOCR
#'
#' @param L1bData
#'
#' @return Tidy long tiblle with Rrs and KLu
#'
#' @noRd
L2_hocr <- function(L1bData, WaveSeq, Z1Depth, Z1Z2Depth,
                    smooth, Obs) {

  L1bDataWide <- L1bData %>%
    mutate(AproxData = purrr::map(
      AproxData,
      ~ pivot_wider(
        .,
        names_from = all_of(c("Type", "Wavelength")),
        names_sep = "_",
        values_from = Channels
      ) %>%
        ungroup()
    )) %>%
    ungroup()

  L1bDataWide <- L1bDataWide %>%
    mutate(AproxData = purrr::map(AproxData, ~ filter(., QC == "1")))

  L1bDataWide <- L1bDataWide %>%
    mutate(AproxData = purrr::map(AproxData, ~ summarise(.x, across(.cols = !matches("ID|QC"), ~ mean(.x, na.rm = T)))))

  ### Approx wavelength
  L1bAverageLong <- L1bDataWide %>%
    mutate(AproxData = purrr::map(
      AproxData,
      ~ pivot_longer(
        .,
        cols = matches("[[:alpha:]]{2}_[[:digit:]]{3}(.[[:digit:]]{1,2})?"),
        values_to = "Channels",
        names_to = c("Type", "Wavelength"),
        names_sep = "_",
        # names_prefix = "[[:alpha:]]{2}_",
        names_transform = list(Wavelength = as.numeric)
      )
    ))

  # This parameter should be an user input
  #WaveSeq <- seq(353, 800, 3)

  approx_wave <- function(., WaveSeq) {
    tbl <- tibble(
      DateTime = unique(.$DateTime),
      Type = unique(.$Type),
      Wavelength = WaveSeq
    )

    for (i in seq_along(colnames(.))[-1:-3]) {
      coord <- approx(x = .[[3]], y = .[[i]], xout = WaveSeq, method = "linear")

      tbl <- bind_cols(tbl, x = coord[[2]])
      colnames(tbl)[i] <- colnames(.)[i]
    }

    tbl

    # tbl %>% mutate(ID = seq_along(TimeSeq))
  }

  L1bAproxLong <- L1bAverageLong %>%
    mutate(IntData = purrr::map(AproxData, ~ approx_wave(., WaveSeq)))

  L1bAproxWide <- L1bAproxLong %>%
    mutate(IntData = purrr::map(
      IntData,
      ~ pivot_wider(
        .,
        names_from = all_of(c("Type", "Wavelength")),
        names_sep = "_",
        values_from = Channels
      )
    )) %>%
    ungroup()

  Es <- L1bAproxWide %>%
    select(!AproxData) %>%
    filter(SN == "1397" | SN == "1396") %>%
    unnest(cols = c(IntData)) %>%
    select(!matches("Instrument|SN|DateTime|CalData|UUID"))

  LuZ1 <- L1bAproxWide %>%
    select(!AproxData) %>%
    filter(SN == "1415" | SN == "1413") %>%
    unnest(cols = c(IntData)) %>%
    select(!matches("Instrument|SN|DateTime|CalData|UUID"))

  LuZ2 <- L1bAproxWide %>%
    select(!AproxData) %>%
    filter(SN == "1416" | SN == "1414") %>%
    unnest(cols = c(IntData)) %>%
    select(!matches("Instrument|SN|DateTime|CalData|UUID"))

  #Z1Z2Depth <- 0.15 # Algae Wise 2022

  KLuWide <- (log(LuZ1) - log(LuZ2)) / Z1Z2Depth

  KLuWide <- rename_with(KLuWide, ~ str_replace(.x, "LU", "KLu"))

  KLuLong <- KLuWide %>%
    pivot_longer(
      .,
      cols = matches("[[:alpha:]]{2}_[[:digit:]]{3}(.[[:digit:]]{1,2})?"),
      values_to = "KLu",
      names_to = c("Wavelength"),
      # names_sep = "_",
      names_prefix = "[[:alpha:]]{3}_",
      names_transform = list(Wavelength = as.numeric)
    )

  if (smooth) {

    KLuloess <- loess(
      KLu ~ Wavelength,
      data = KLuLong,
      na.action = "na.omit",
      span = 0.2
    )

    KLuLong <- KLuLong %>%
      mutate(
        KLu_loess = predict(KLuloess, Wavelength)
      )

    KLuWide <- KLuLong %>%
      select(Wavelength, KLu_loess) %>%
      pivot_wider(
        names_from = "Wavelength",
        names_prefix = "KLu_loess_",
        names_sep = "_",
        values_from = c(KLu_loess)
      )

  }


# RbII computation --------------------------------------------------------
  EsLong <- L1bAproxLong %>%
    select(!AproxData) %>%
    filter(SN == "1397" | SN == "1396") %>%
    unnest(cols = c(IntData)) %>%
    select(!matches("Instrument|SN|DateTime|CalData|UUID|Type")) %>%
    rename(Es = Channels)

  LuZ2Long <- L1bAproxLong %>%
    select(!AproxData) %>%
    filter(SN == "1416" | SN == "1414") %>%
    unnest(cols = c(IntData)) %>%
    select(!matches("Instrument|SN|DateTime|CalData|UUID|Type")) %>%
    rename(LuZ2 = Channels)

  RbII <- left_join(KLuLong, EsLong, by = c("Wavelength")) %>%
    left_join(LuZ2Long, by = c("Wavelength"))

  RbII <- RbII %>%
    mutate(
      Esb = Es/exp(-KLu_loess*Obs$BioSonic$L2$BottomElevation_m),
      Lub = LuZ2/exp(-KLu_loess*Obs$BioSonic$L2$BottomElevation_m),
      RbII = Lub/Esb
    )

  #Z1Depth <- 0.10 # 10 cm

  Lw <- 0.54 * LuZ1 / exp(-Z1Depth * KLuWide)
  RrsWide <- Lw / Es

  RrsLong <- RrsWide %>%
    pivot_longer(
      .,
      cols = matches("[[:alpha:]]{2}_[[:digit:]]{3}(.[[:digit:]]{1,2})?"),
      values_to = "Rrs",
      names_to = c("Wavelength"),
      # names_sep = "_",
      names_prefix = "[[:alpha:]]{2}_",
      names_transform = list(Wavelength = as.numeric)
    )

  if (smooth) {

    Rrsloess <- loess(
      Rrs ~ Wavelength,
      data = RrsLong,
      na.action = "na.omit",
      span = 0.2
    )

    RrsLong <- RrsLong %>%
      mutate(
        Rrs_loess = predict(Rrsloess, Wavelength)
      )

  }

  L2Data <- left_join(RrsLong, RbII, by = "Wavelength") #%>%
   # left_join(, by = "Wavelength")

  # Populate UUID if exist
  if (any(names(L1bData) == "UUID")) {
    L2Data <- L2Data %>%
      mutate(UUID = unique(L1bData$UUID))
  }

  return(L2Data)
}
